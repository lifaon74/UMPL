

<%
	
/**
	Arduino optimizer
**/

var _const = {};

_const.getConstvalue = function(search_const) {
	var subConst;
	for(subConstKey in this) {
		subConst = this[subConstKey];
		if(!_.isUndefined(subConst[search_const])) {
			return subConst[search_const];
		}
	}
};

_const.microcontrollers = _.enumerate([
	"ATMEGA328P",
	"ATMEGA32U4"
]);

_const.pinMode = {
	"INPUT"			: 0,
	"OUTPUT"		: 1,
	"INPUT_PULLUP"	: 2
};

_const.pinState = {
	"LOW"	: 0,
	"HIGH"	: 1 
};



_const.pins = {
	"D0"	: 0 ,
	"D1"	: 1,
	"D2"	: 2,
	"D3"	: 3,
	"D4"	: 4,
	"D5"	: 5,
	"D6"	: 6,
	"D7"	: 7,
	"D8"	: 8,
	"D9"	: 9,
	"D10"	: 10,
	"D11"	: 11,
	"D12"	: 12,
	"D13"	: 13,
	
	"A0"	: 16,
	"A1"	: 17,
	"A2"	: 18,
	"A3"	: 19,
	"A4"	: 20,
	"A5"	: 21/*,
	"A6"	: 22,
	"A7"	: 23*/
};
	
	
	// use $globals to store variables through different levels
$globals._const = _const;




var ATMEGA328P = function() {
	var self = this;
	self._const = _const;
	
};

ATMEGA328P.prototype.functions = [];

/*ATMEGA328P.prototype.getCPPFunction = function(_function) {
	
	if(_.isString(_function.outside)) {
		string += _function.outside + "\n";
	}
		
	string += _function.returnType + " " + fncName + "(";
	for(var i = 0; i < 
		
	return string;
};*/

ATMEGA328P.prototype.getCPPFunctions = function() {
	var self = this;
	var string = "";
	for(var i = 0; i < self.functions.length; i++) {
		var fncName = self.functions[i];
		var fnc = self[fncName];
		
		if(self[fncName].cpp.used) {
			string += self[fncName].cpp.code.trim() + "\n\n";
		}
	}
	
	return string;
};

ATMEGA328P.prototype.setup = function(number) {
};


ATMEGA328P.prototype.convertNumberToByte = function(number) {
	if(number instanceof VString) {
		return number;
	} else {
		var bitString = "B";
		for(var i = 7; i >= 0; i--) {
			bitString += (number >> i) & 1;
		}
		return bitString;
	}
};

ATMEGA328P.prototype.invert = function(number) {
	if(_.isNumber(number)) {
		return (~number & 0b11111111);
	} else if(number instanceof VString) {
		return new VString("~(" + number.toString() + ")");
	} else {
		throw {
			message: "unknow number type",
			number: number
		};
	}
};

ATMEGA328P.prototype.tryToConvert = function(_var, type) {
	var self = this;
	
	if(_var instanceof VString) {
		return _var;
	} else if(_.isString(_var)) {
		_var = _const.getConstvalue(_var);
		if(_.isUndefined(_var)) {
			throw {
				message: "unknown constant",
				_var: _var
			};
		} else {
			return self.tryToConvert(_var, type);
		}
	} else {
		return _.convert(_var, type, function(_var, success) {
			if(success) {
				return _var;
			} else {
				throw {
					message: "unknown type",
					_var: _var
				};
			}
		});
	}
		
};


	// _pinToIOMask
ATMEGA328P.prototype._pinToIOMask = function(pin) {
	var self	= this;
	var fnc		= arguments.callee;

	pin = self.tryToConvert(pin, "number");
	if(pin instanceof VString) {
		return new VString("(1 << (" + pin.toString() + " % 8))");
	} else {
		if((0 <= pin) && (pin < 8)) {
			return 1 << pin;
		} else if((8 <= pin) && (pin < 14)) {
			return 1 << (pin - 8);
		} else if((16 <= pin) && (pin < 22)) {
			return 1 << (pin - 16);
		} else {
			throw {
				message: "unknow pin number",
				pin: pin
			};
		}
	}
};

	// _pinToIOPort
ATMEGA328P.prototype._pinToIOPort = function(pin, port, _function) {
	var self	= this;
	var fnc		= arguments.callee;
	
	pin = self.tryToConvert(pin, "number");
	if(pin instanceof VString) {
		_function.cpp.used = true;
		return new VString("*pinTo" + port + "Array[" + pin.toString() + " / 8]");
	} else {
		if((0 <= pin) && (pin < 8)) {
			return port + "D";
		} else if((8 <= pin) && (pin < 14)) {
			return port + "B";
		} else if((16 <= pin) && (pin < 22)) {
			return port + "C";
		} else {
			throw {
				message: "unknow pin number",
				pin: pin
			};
		}
	}
};


/** pinMode **/
	
	// pinToDDRMask
ATMEGA328P.prototype.pinToDDRMask = function(pin) {
	return this._pinToIOMask(pin);
};

	// pinToDDR
ATMEGA328P.prototype.functions.push('pinToDDR');
ATMEGA328P.prototype.pinToDDR = function(pin) {
	return this._pinToIOPort(pin, 'DDR', arguments.callee);
};

ATMEGA328P.prototype.pinToDDR.cpp = {
	code: =%>
		volatile uint8_t * pinToDDRArray[] = { &DDRD, &DDRB, &DDRC }; 
	<% ,
	ram: 6, // 6b in RAM, it's fine
	used: false
};

	
ATMEGA328P.prototype.pinMode = function(pin, mode) {
	var self = this;
	
	mode = self.tryToConvert(mode, "number");
	if(mode instanceof VString) {
		return new VString(
			=%>
				switch(<%= mode =%>) {
					case <%= self._const.pinMode.INPUT =%> :
						<%= self.pinMode(pin, self._const.pinMode.INPUT) =%>
					break;
					case <%= self._const.pinMode.OUTPUT =%> :
						<%= self.pinMode(pin, self._const.pinMode.OUTPUT) =%>
					break;
					case <%= self._const.pinMode.INPUT_PULLUP =%> :
						<%= self.pinMode(pin, self._const.pinMode.INPUT_PULLUP) =%>
					break;
				}
			<%
		);
	} else {
		switch(mode) {
			case self._const.pinMode.INPUT:
				return self.pinToDDR(pin).toString() + " &= " + self.convertNumberToByte(self.invert(self.pinToDDRMask(pin))).toString() + ";";
			break;
			case self._const.pinMode.OUTPUT:
				return self.pinToDDR(pin).toString() + " |= " + self.convertNumberToByte(self.pinToDDRMask(pin)).toString() + ";";
			break;
			case self._const.pinMode.INPUT_PULLUP:
				return self.pinMode(pin, self._const.pinMode.INPUT) + " " + self.digitalWrite(pin, self._const.pinState.HIGH);
			break;
		}
	}
};


/** digitalWrite **/

	// pinToPORTMask
ATMEGA328P.prototype.pinToPORTMask = function(pin) {
	return this._pinToIOMask(pin);
};


	// pinToPORT
ATMEGA328P.prototype.functions.push('pinToPORT');
ATMEGA328P.prototype.pinToPORT = function(pin) {
	return this._pinToIOPort(pin, 'PORT', arguments.callee);
};

ATMEGA328P.prototype.pinToPORT.cpp = {
	code: =%>
		volatile uint8_t * pinToPORTArray[] = { &PORTD, &PORTB, &PORTC };
	<% ,
	ram: 6,
	used: false
};


/*
	@8Mhz
	
	default:
		const, const	: 10.8µs
		const, var		:
		var, const		: 
		var, var		: 11.9µs
	
	optimized:
		const, const	: 1.2µs (cpp const : 2.3µs);
		const, var		:
		var, const		: 
		var, var		: 3.6µs
*/

ATMEGA328P.prototype.digitalWrite = function(pin, state) {
	var self = this;
	
	state = self.tryToConvert(state, "boolean");
	if(state instanceof VString) {
		return new VString(
			"if(" + state.toString() + ") {" +
				self.digitalWrite(pin, true) +
			"} else {" +
				self.digitalWrite(pin, false) +
			"}"
		);
	} else {
		if(state) {
			return self.pinToPORT(pin).toString() + " |= " + self.convertNumberToByte(self.pinToPORTMask(pin)).toString() + ";";
		} else {
			return self.pinToPORT(pin).toString() + " &= " + self.convertNumberToByte(self.invert(self.pinToPORTMask(pin))).toString() + ";";
		}
	}
};


/** digitalRead **/

	// pinToPINMask
ATMEGA328P.prototype.pinToPINMask = function(pin) {
	return this._pinToIOMask(pin);
};

	// pinToPIN
ATMEGA328P.prototype.functions.push('pinToPIN');
ATMEGA328P.prototype.pinToPIN = function(pin) {
	return this._pinToIOPort(pin, 'PIN', arguments.callee);
};

ATMEGA328P.prototype.pinToPIN.cpp = {
	code: =%>
		volatile uint8_t * pinToPINArray[] = { &PIND, &PINB, &PINC };
	<% ,
	ram: 6,
	used: false
};

	
ATMEGA328P.prototype.digitalRead = function(pin) {
	var self = this;
	return "((bool) (" + self.pinToPIN(pin).toString() + " & " + self.convertNumberToByte(self.pinToPINMask(pin)).toString() + "))";
};




$globals.ATMEGA328P = ATMEGA328P;

	
	var microcontroller = new ATMEGA328P();
	
	var raw = function(string) {
		return new VString(string);
	};
%>


/*
three ways of writing the same function :

	
	<%= microcontroller.digitalWrite('D5', 'HIGH') %> // giving D5 constant as a string
	<%= microcontroller.digitalWrite(_const.pins.D5, 'HIGH') %> // giving D5 constant from the _const object
	<%= microcontroller.digitalWrite(5, 'HIGH') %> // giving number 5 
*/

<%
	/**
		Why UMPL is useful ? you'll see :
	**/
	
		// we define constants here and not in the C++ code
	var ledPin	= "D13";
%>

	
	// the code inside of this function is strongly optimized
void blink_fast() { // 2.4µs @8Mhz > 1.2µs / write
	<%= microcontroller.digitalWrite(ledPin, 'HIGH') %>
	<%= microcontroller.digitalWrite(ledPin, 'LOW') %>
};


#define LED_PIN 13

	// the code inside of this function is not optimized at the best because we use a C++ constant 
void blink_slow() { // 4.5µs @8Mhz > 2.3µs / write
	<%= microcontroller.digitalWrite(raw('LED_PIN'), raw('HIGH')) %>
	<%= microcontroller.digitalWrite(raw('LED_PIN'), raw('LOW')) %>
};

	// the code inside of this function is the slowest, digitalWrite is provided by the Arduino IDE
void blink_slower() { // 21.6µs @8Mhz  > 10.8µs / write
	digitalWrite(LED_PIN, HIGH);
	digitalWrite(LED_PIN, LOW);
};


/**
	The following code can't be optimized by the c++ compiler, so it will only show the arduino.js optimizations.
**/

void blink_fast_2() { // 94.7µs @8Mhz > 3.6µs / write
	for(uint8_t i = 0; i < 13; i++) {
		for(uint8_t j = 0; j < 2; j++) {
			<%= microcontroller.digitalWrite(raw('i'), raw('j')) %>
		}
	}
};

void blink_slower_2() { // 309.2µs @8Mhz > 11.9µs / write
	for(uint8_t i = 0; i < 13; i++) {
		for(uint8_t j = 0; j < 2; j++) {
			digitalWrite(i, j);
		}
	}
};


/**
	Verdict : if you use arduino.js methods instead of native Arduino IDE function,
	you'll reduce a least the process time by 3.3 and at the best 9 times faster !
	Worth it no ?
**/




void pinmode_fast() { // 2.3µs @8Mhz
	<%= microcontroller.pinMode(ledPin, 'OUTPUT') %>
};


void pinmode_slow() { // 10µs @8Mhz
	pinMode(LED_PIN, OUTPUT);
};



uint32_t time_0;
uint32_t time_1;

void setup() {
	Serial.begin(115200);
	
	/*Serial.println(INPUT, DEC);
	Serial.println(INPUT_PULLUP, DEC);
	Serial.println(OUTPUT, DEC);*/
	
	<%

		var exec_num = 1000;
		['blink_fast', 'blink_slow', 'blink_slower', 'blink_fast_2', 'blink_slower_2', 'pinmode_fast', 'pinmode_slow'].forEach(function(fnc) {
			%>
			
				time_0 = micros();
				for(uint32_t i = 0; i < <%= exec_num %>; i++) {
					<%= fnc %>();
				}
				
				time_1 = micros();
				Serial.print("<%= fnc %> takes ");
				Serial.print(((float) (time_1 - time_0)) / <%= exec_num %>, DEC);
				Serial.println(" microseconds");
			<%
		});
	%>
	
	<%= microcontroller.pinMode(ledPin, 'OUTPUT') %>
	<%= microcontroller.pinMode(10, 'INPUT') %>
}


void loop() {
	<%= microcontroller.digitalWrite(raw('LED_PIN'), raw('HIGH')) %>
	delay(100);
	<%= microcontroller.digitalWrite(raw('LED_PIN'), raw('LOW')) %>
	delay(100);
	
	uint8_t i = 10;
	Serial.println(<%= microcontroller.digitalRead(raw('i')) %>, DEC);
}


<%
	// I'm injecting here the necessaries functions
	$buffer.set(microcontroller.getCPPFunctions() + $buffer.toString());
%>

	