$buffer.push("");

		// here I put a security : if we loop more than 1000 times, we stop all
	$compiler.bind('execute_loop', function() {
		if($compiler.loop > 100) {
			throw "security infinite loop break";
		}
	});
	
	var tools = require('tools');
		// use $scope to have the variable _ on all the following loops, this way, it's possible to require just one time 'tools'
	$scope['_'] = tools._;$buffer.push("\r\n\r\n<%\r\n\t/**\r\n\t\tArduino optimizer\r\n\t**/\r\n\t\r\n\tvar _const = {};\r\n\t\r\n\t_const.getConstvalue = function(search_const) {\r\n\t\tvar subConst;\r\n\t\tfor(subConstKey in this) {\r\n\t\t\tsubConst = this[subConstKey];\r\n\t\t\tif(!_.isUndefined(subConst[search_const])) {\r\n\t\t\t\treturn subConst[search_const];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t_const.microcontrollers = _.enumerate([\r\n\t\t\"ATMEGA328P\",\r\n\t\t\"ATMEGA32U4\"\r\n\t]);\r\n\t\r\n\t_const.pinState = {\r\n\t\t\"HIGH\"\t: 1 ,\r\n\t\t\"LOW\"\t: 0\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t_const.pins = {\r\n\t\t\"D0\"\t: 0 ,\r\n\t\t\"D1\"\t: 1,\r\n\t\t\"D2\"\t: 2,\r\n\t\t\"D3\"\t: 3,\r\n\t\t\"D4\"\t: 4,\r\n\t\t\"D5\"\t: 5,\r\n\t\t\"D6\"\t: 6,\r\n\t\t\"D7\"\t: 7,\r\n\t\t\"D8\"\t: 8,\r\n\t\t\"D9\"\t: 9,\r\n\t\t\"D10\"\t: 10,\r\n\t\t\"D11\"\t: 11,\r\n\t\t\"D12\"\t: 12,\r\n\t\t\"D13\"\t: 13,\r\n\t\t\r\n\t\t\"A0\"\t: 16,\r\n\t\t\"A1\"\t: 17,\r\n\t\t\"A2\"\t: 18,\r\n\t\t\"A3\"\t: 19,\r\n\t\t\"A4\"\t: 20,\r\n\t\t\"A5\"\t: 21/*,\r\n\t\t\"A6\"\t: 22,\r\n\t\t\"A7\"\t: 23*/\r\n\t};\r\n\t\t\r\n\t\t\r\n\t\t// use $globals to store variables through different levels\r\n\t$globals._const = _const;\r\n\r\n%>\r\n\r\n<%\r\n\tvar ATMEGA328P = function() {\r\n\t\tvar self = this;\r\n\t\tself._const = _const;\r\n\t\t\r\n\t};\r\n\r\n\tATMEGA328P.prototype.functions = [];\r\n\t\r\n\t/*ATMEGA328P.prototype.getCPPFunction = function(_function) {\r\n\t\t\r\n\t\tif(_.isString(_function.outside)) {\r\n\t\t\tstring += _function.outside + \"\\n\";\r\n\t\t}\r\n\t\t\t\r\n\t\tstring += _function.returnType + \" \" + fncName + \"(\";\r\n\t\tfor(var i = 0; i < \r\n\t\t\t\r\n\t\treturn string;\r\n\t};*/\r\n\t\r\n\tATMEGA328P.prototype.getCPPFunctions = function() {\r\n\t\tvar self = this;\r\n\t\tvar string = \"\";\r\n\t\tfor(var i = 0; i < self.functions.length; i++) {\r\n\t\t\tvar fncName = self.functions[i];\r\n\t\t\tvar fnc = self[fncName];\r\n\t\t\t\r\n\t\t\tif(fnc.storeRAM) {\r\n\t\t\t\tvar values = \"\";\r\n\t\t\t\tfor(var j = 0; j < fnc.cppStore.size[0]; j++) {\r\n\t\t\t\t\tif(j > 0) { values += \", \"; }\r\n\t\t\t\t\tvar prefix = fnc.cppStore.prefix || \"\";\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tvalues += prefix + fnc.apply(self, [j]);\r\n\t\t\t\t\t} catch(error) {\r\n\t\t\t\t\t\tvalues += \"NULL\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tstring += fnc.cppStore.type + \" \" + fncName + \"Array[] = { \" + values + \"};\\n\\n\";\t\r\n\t\t\t} else {\r\n\t\t\t\tstring += self[fncName].cpp.trim() + \"\\n\\n\";\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn string;\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.setup = function(number) {\r\n\t};\r\n\t\r\n\t\r\n\tATMEGA328P.prototype.convertNumberToByte = function(number) {\r\n\t\tif(number instanceof VString) {\r\n\t\t\treturn number;\r\n\t\t} else {\r\n\t\t\tvar bitString = \"B\";\r\n\t\t\tfor(var i = 7; i >= 0; i--) {\r\n\t\t\t\tbitString += (number >> i) & 1;\r\n\t\t\t}\r\n\t\t\treturn bitString;\r\n\t\t}\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.invert = function(number) {\r\n\t\tif(_.isNumber(number)) {\r\n\t\t\treturn (~number & 0b11111111);\r\n\t\t} else if(number instanceof VString) {\r\n\t\t\treturn new VString(\"~(\" + number.toString() + \")\");\r\n\t\t} else {\r\n\t\t\tthrow {\r\n\t\t\t\tmessage: \"unknow number type\",\r\n\t\t\t\tnumber: number\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.tryToConvert = function(_var, type) {\r\n\t\tvar self = this;\r\n\t\t\r\n\t\tif(_var instanceof VString) {\r\n\t\t\treturn _var;\r\n\t\t} else if(_.isString(_var)) {\r\n\t\t\t_var = _const.getConstvalue(_var);\r\n\t\t\tif(_.isUndefined(_var)) {\r\n\t\t\t\tthrow {\r\n\t\t\t\t\tmessage: \"unknown constant\",\r\n\t\t\t\t\t_var: _var\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\treturn self.tryToConvert(_var, type);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn _.convert(_var, type, function(_var, success) {\r\n\t\t\t\tif(success) {\r\n\t\t\t\t\treturn _var;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow {\r\n\t\t\t\t\t\tmessage: \"unknown type\",\r\n\t\t\t\t\t\t_var: _var\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\t// pinToPORTMask\r\n\tATMEGA328P.prototype.pinToPORTMask = function(pin) {\r\n\t\tvar self\t= this;\r\n\t\tvar fnc\t\t= arguments.callee;\r\n\t\r\n\t\tpin = self.tryToConvert(pin, \"number\");\r\n\t\tif(pin instanceof VString) {\r\n\t\t\treturn new VString(\"(1 << (\" + pin.toString() + \" % 8))\");\r\n\t\t} else {\r\n\t\t\tif((0 <= pin) && (pin < 8)) {\r\n\t\t\t\treturn 1 << pin;\r\n\t\t\t} else if((8 <= pin) && (pin < 14)) {\r\n\t\t\t\treturn 1 << (pin - 8);\r\n\t\t\t} else if((16 <= pin) && (pin < 22)) {\r\n\t\t\t\treturn 1 << (pin - 16);\r\n\t\t\t} else {\r\n\t\t\t\tthrow {\r\n\t\t\t\t\tmessage: \"unknow pin number\",\r\n\t\t\t\t\tpin: pin\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t\r\n\t\t// pinToPORT\r\n\tATMEGA328P.prototype.functions.push('pinToPORT');\r\n\tATMEGA328P.prototype.pinToPORT = function(pin) {\r\n\t\tvar self\t= this;\r\n\t\tvar fnc\t\t= arguments.callee;\r\n\t\t\r\n\t\tpin = self.tryToConvert(pin, \"number\");\r\n\t\tif(pin instanceof VString) {\r\n\t\t\treturn new VString(\"*pinToPORTArray[\" + pin.toString() + \" / 8]\");\r\n\t\t} else {\r\n\t\t\tif((0 <= pin) && (pin < 8)) {\r\n\t\t\t\treturn \"PORTD\";\r\n\t\t\t} else if((8 <= pin) && (pin < 14)) {\r\n\t\t\t\treturn \"PORTB\";\r\n\t\t\t} else if((16 <= pin) && (pin < 22)) {\r\n\t\t\t\treturn \"PORTC\";\r\n\t\t\t} else {\r\n\t\t\t\tthrow {\r\n\t\t\t\t\tmessage: \"unknow pin number\",\r\n\t\t\t\t\tpin: pin\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.pinToPORT.cpp = =%>\r\n\t\tvolatile uint8_t * pinToPORTArray[] = { &PORTD, &PORTB, &PORTC }; // 6b in RAM, it's fine\r\n\t<% ;\r\n\t\r\n\t\r\n\tATMEGA328P.prototype.digitalWrite = function(pin, state) {\r\n\t\tvar self = this;\r\n\t\t\r\n\t\tstate = self.tryToConvert(state, \"boolean\");\r\n\t\tif(state instanceof VString) {\r\n\t\t\treturn new VString(\r\n\t\t\t\t\"if(\" + state.toString() + \") {\" +\r\n\t\t\t\t\tself.digitalWrite(pin, true) +\r\n\t\t\t\t\"} else {\" +\r\n\t\t\t\t\tself.digitalWrite(pin, false) +\r\n\t\t\t\t\"}\"\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tif(state) {\r\n\t\t\t\treturn self.pinToPORT(pin).toString() + \" |= \" + self.convertNumberToByte(self.pinToPORTMask(pin)).toString() + \";\";\r\n\t\t\t} else {\r\n\t\t\t\treturn self.pinToPORT(pin).toString() + \" &= \" + self.convertNumberToByte(self.invert(self.pinToPORTMask(pin))).toString() + \";\";\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\tvar microcontroller = new ATMEGA328P();\r\n\t\r\n\tvar raw = function(string) {\r\n\t\treturn new VString(string);\r\n\t};\r\n%>\r\n\r\n/*\r\nthree ways of writing the same function :\r\n\r\n\t\r\n\t<%= microcontroller.digitalWrite('D5', 'HIGH') %> // giving D5 constant as a string\r\n\t<%= microcontroller.digitalWrite(_const.pins.D5, 'HIGH') %> // giving D5 constant from the _const object\r\n\t<%= microcontroller.digitalWrite(5, 'HIGH') %> // giving number 5 \r\n*/\r\n\r\n<%\r\n\t/**\r\n\t\tWhy UMPL is useful ? you'll see :\r\n\t**/\r\n\t\r\n\t\t// we define constants here and not in the C++ code\r\n\tvar ledPin\t= \"D13\";\r\n%>\r\n\r\n\t// we need it a the beginning of our program to setup some functions\r\n<%= microcontroller.getCPPFunctions() %>\r\n\r\n\r\n\t// the code inside of this function is strongly optimized\r\nvoid blink_fast() { // 2.4µs @8Mhz > 1.2µs / write\r\n\t<%= microcontroller.digitalWrite(ledPin, 'HIGH') %>\r\n\t<%= microcontroller.digitalWrite(ledPin, 'LOW') %>\r\n};\r\n\r\n\r\n#define LED_PIN 13\r\n\r\n\t// the code inside of this function is not optimized at the best because we use a C++ constant \r\nvoid blink_slow() { // 4.5µs @8Mhz > 2.3µs / write\r\n\t<%= microcontroller.digitalWrite(raw('LED_PIN'), raw('HIGH')) %>\r\n\t<%= microcontroller.digitalWrite(raw('LED_PIN'), raw('LOW')) %>\r\n};\r\n\r\n\t// the code inside of this function is the slowest, digitalWrite is provided by the Arduino IDE\r\nvoid blink_slower() { // 21.6µs @8Mhz  > 10.8µs / write\r\n\tdigitalWrite(LED_PIN, HIGH);\r\n\tdigitalWrite(LED_PIN, LOW);\r\n};\r\n\r\n\r\n/**\r\n\tThe following code can't be optimized by the c++ compiler, so it will only show the arduino.js optimizations\r\n**/\r\n\r\nvoid blink_fast_2() { // 94.7µs @8Mhz > 3.6µs / write\r\n\tfor(uint8_t i = 0; i < 13; i++) {\r\n\t\tfor(uint8_t j = 0; j < 2; j++) {\r\n\t\t\t<%= microcontroller.digitalWrite(raw('i'), raw('j')) %>\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvoid blink_slower_2() { // 309.2µs @8Mhz > 11.9µs / write\r\n\tfor(uint8_t i = 0; i < 13; i++) {\r\n\t\tfor(uint8_t j = 0; j < 2; j++) {\r\n\t\t\tdigitalWrite(i, j);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\n/**\r\n\tVerdict : if you use arduino.js methods instead of native Arduino IDE function,\r\n\tyou'll reduce a least the process time by 3.3 and at the best 9 times faster !\r\n**/\r\n\r\n\r\n\r\nuint32_t time_0;\r\nuint32_t time_1;\r\n\r\nvoid setup() {\r\n\tSerial.begin(115200);\r\n\t\r\n\t<%\r\n\r\n\t\tvar exec_num = 10000;\r\n\t\t['blink_fast', 'blink_slow', 'blink_slower', 'blink_fast_2', 'blink_slower_2'].forEach(function(fnc) {\r\n\t\t\t%>\r\n\t\t\t\r\n\t\t\t\ttime_0 = micros();\r\n\t\t\t\tfor(uint32_t i = 0; i < <%= exec_num %>; i++) {\r\n\t\t\t\t\t<%= fnc %>();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ttime_1 = micros();\r\n\t\t\t\tSerial.print(\"<%= fnc %> takes \");\r\n\t\t\t\tSerial.print(((float) (time_1 - time_0)) / <%= exec_num %>, DEC);\r\n\t\t\t\tSerial.println(\" microseconds\");\r\n\t\t\t<%\r\n\t\t});\r\n\t%>\r\n\t\r\n\t<%= microcontroller.digitalWrite(ledPin, 'HIGH') %>\r\n\t<%= microcontroller.digitalWrite(ledPin, 'LOW') %>\r\n}\r\n\r\n\r\nvoid loop() {\r\n\t<%= microcontroller.digitalWrite(new VString('LED_PIN'), new VString('HIGH')) %>\r\n\tdelay(100);\r\n\t<%= microcontroller.digitalWrite(new VString('LED_PIN'), new VString('LOW')) %>\r\n\tdelay(100);\r\n}\r\n\r\n\r\n\t");