$buffer.push("");

		// here I put a security : if we loop more than 1000 times, we stop all
	$compiler.bind('execute_loop', function() {
		if($compiler.loop > 100) {
			throw "security infinite loop break";
		}
	});
	
	var tools = require('tools');
		// use $scope to have the variable _ on all the following loops, this way, it's possible to require just one time 'tools'
	$scope['_'] = tools._;$buffer.push("\r\n\r\n<%\r\n\t/**\r\n\t\tArduino optimizer\r\n\t**/\r\n\t\r\n\tvar _const = {};\r\n\t\r\n\t_const.getConstvalue = function(search_const) {\r\n\t\tvar subConst;\r\n\t\tfor(subConstKey in this) {\r\n\t\t\tsubConst = this[subConstKey];\r\n\t\t\tif(!_.isUndefined(subConst[search_const])) {\r\n\t\t\t\treturn subConst[search_const];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t_const.microcontrollers = _.enumerate([\r\n\t\t\"ATMEGA328P\",\r\n\t\t\"ATMEGA32U4\"\r\n\t]);\r\n\t\r\n\t_const.pinState = {\r\n\t\t\"HIGH\"\t: 1 ,\r\n\t\t\"LOW\"\t: 0\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t_const.pins = {\r\n\t\t\"D0\"\t: 0 ,\r\n\t\t\"D1\"\t: 1,\r\n\t\t\"D2\"\t: 2,\r\n\t\t\"D3\"\t: 3,\r\n\t\t\"D4\"\t: 4,\r\n\t\t\"D5\"\t: 5,\r\n\t\t\"D6\"\t: 6,\r\n\t\t\"D7\"\t: 7,\r\n\t\t\"D8\"\t: 8,\r\n\t\t\"D9\"\t: 9,\r\n\t\t\"D10\"\t: 10,\r\n\t\t\"D11\"\t: 11,\r\n\t\t\"D12\"\t: 12,\r\n\t\t\"D13\"\t: 13,\r\n\t\t\r\n\t\t\"A0\"\t: 16,\r\n\t\t\"A1\"\t: 17,\r\n\t\t\"A2\"\t: 18,\r\n\t\t\"A3\"\t: 19,\r\n\t\t\"A4\"\t: 20,\r\n\t\t\"A5\"\t: 21/*,\r\n\t\t\"A6\"\t: 22,\r\n\t\t\"A7\"\t: 23*/\r\n\t};\r\n\t\t\r\n\t\t\r\n\t\t// use $globals to store variables through different levels\r\n\t$globals._const = _const;\r\n\r\n%>\r\n\r\n<%\t\r\n\t\r\n\t<%\r\n\t\t\t// this is here to show how we can translate the same function in JS or in C++\r\n\t\tvar pinToPORTMask = function(isCpp) {\r\n\t\t\tvar _return = \"\";\r\n\t\t\t\r\n\t\t\tif(isCpp) {\r\n\t\t\t\t\t// this special close_tag will convert following text into string instead of outputting it into buffer\r\n\t\t\t\t_return += =%> unsigned char pinToPORTMask(unsigned char pin) { <% ;\r\n\t\t\t} else {\r\n\t\t\t\t_return += =%> function(pin) { <% ;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t_return += =%>\r\n\t\t\t\t\t\r\n\t\t\t\tif((0 <= pin) && (pin < 8)) {\r\n\t\t\t\t\t\treturn 1 << pin;\r\n\t\t\t\t\t} else if((8 <= pin) && (pin < 14)) {\r\n\t\t\t\t\t\treturn 1 << (pin - 8);\r\n\t\t\t\t\t} else if((16 <= pin) && (pin < 22)) {\r\n\t\t\t\t\t\treturn 1 << (pin - 16);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t<% ;\r\n\t\t\t\t\t\t\tif(isCpp) {\r\n\t\t\t\t\t\t\t\t_return += =%> return NULL; <% ;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t_return += =%> throw {\r\n\t\t\t\t\t\t\t\t\tmessage: \"unknow pin number\",\r\n\t\t\t\t\t\t\t\t\tpin: pin\r\n\t\t\t\t\t\t\t\t}; <% ;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t_return +=\r\n\t\t\t\t\t\t=%>\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t<% ;\r\n\t\t\t\t\r\n\t\t\treturn _return;\r\n\t\t}\r\n\t\t\r\n\t\t// pinToPORTMask(false); to get the JS function\r\n\t\t// pinToPORTMask(true); to get the C++ function\r\n\t%>\r\n\t\r\n\tvar ATMEGA328P = function() {\r\n\t\tvar self = this;\r\n\t\tself._const = _const;\r\n\t\t\r\n\t\tself.cpp_functions = {\r\n\t\t\t'pinToPORTMask': =%>\r\n\t\t\t\t<%+2= pinToPORTMask(true) %>\r\n\t\t\t<% ,\r\n\t\t\t'pinToPORT':\r\n\r\n\t\t\t\t=%>\r\n\t\t\t\t\tvolatile unsigned char * pinToPORT(unsigned char pin) {\r\n\t\t\t\t\t\tif((0 <= pin) && (pin < 8)) {\r\n\t\t\t\t\t\t\treturn &PORTD;\r\n\t\t\t\t\t\t} else if((8 <= pin) && (pin < 14)) {\r\n\t\t\t\t\t\t\treturn &PORTB;\r\n\t\t\t\t\t\t} else if((16 <= pin) && (pin < 22)) {\r\n\t\t\t\t\t\t\treturn &PORTB;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn NULL;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t<%\r\n\t\t};\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.getCPPFunctions = function(number) {\r\n\t\tvar self = this;\r\n\t\tvar string = \"\";\r\n\t\tfor(fnc in self.cpp_functions) {\r\n\t\t\tstring += self.cpp_functions[fnc] + \"\\n\";\r\n\t\t}\r\n\t\t\r\n\t\treturn string;\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.setup = function(number) {\r\n\t};\r\n\t\r\n\t\r\n\tATMEGA328P.prototype.convertNumberToByte = function(number) {\r\n\t\tif(number instanceof VString) {\r\n\t\t\treturn number;\r\n\t\t} else {\r\n\t\t\tvar bitString = \"B\";\r\n\t\t\tfor(var i = 7; i >= 0; i--) {\r\n\t\t\t\tbitString += (number >> i) & 1;\r\n\t\t\t}\r\n\t\t\treturn bitString;\r\n\t\t}\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.invert = function(number) {\r\n\t\tif(_.isNumber(number)) {\r\n\t\t\treturn (~number & 0b11111111);\r\n\t\t} else if(number instanceof VString) {\r\n\t\t\treturn new VString(\"~(\" + number.toString() + \")\");\r\n\t\t} else {\r\n\t\t\tthrow {\r\n\t\t\t\tmessage: \"unknow number type\",\r\n\t\t\t\tnumber: number\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.tryToConvert = function(_var, type) {\r\n\t\tvar self = this;\r\n\t\t\r\n\t\tif(_var instanceof VString) {\r\n\t\t\treturn _var;\r\n\t\t} else {\r\n\t\t\tswitch(type) {\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\t\tif(_.isNumber(_var)) {\r\n\t\t\t\t\t\treturn _var * 1;\r\n\t\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase \"bool\":\r\n\t\t\t\t\tif(_.isBool(_var)) {\r\n\t\t\t\t\t\treturn _var;\r\n\t\t\t\t\t} else if(_.isNumber(_var)) {\r\n\t\t\t\t\t\treturn _var ? true : false;\r\n\t\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(_.isString(_var)) {\r\n\t\t\t\t_var = _const.getConstvalue(_var);\r\n\t\t\t\tif(_.isUndefined(_var)) {\r\n\t\t\t\t\tthrow {\r\n\t\t\t\t\t\tmessage: \"unknown constant\",\r\n\t\t\t\t\t\t_var: _var\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn self.tryToConvert(_var, type);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow {\r\n\t\t\t\t\tmessage: \"unknown type\",\r\n\t\t\t\t\t_var: _var\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.pinToPORTMask = function(pin) {\r\n\t\tvar self = this;\r\n\t\r\n\t\tpin = self.tryToConvert(pin, \"number\");\r\n\t\tif(pin instanceof VString) {\r\n\t\t\treturn new VString(\"pinToPORTMask(\" + pin.toString() + \")\");\r\n\t\t} else {\r\n\t\t\tdebugger;\r\n\t\t\r\n\t\t\treturn (<%= pinToPORTMask(false) %>)(pin);\r\n\t\t\t/*if((0 <= pin) && (pin < 8)) {\r\n\t\t\t\treturn 1 << pin;\r\n\t\t\t} else if((8 <= pin) && (pin < 14)) {\r\n\t\t\t\treturn 1 << (pin - 8);\r\n\t\t\t} else if((16 <= pin) && (pin < 22)) {\r\n\t\t\t\treturn 1 << (pin - 16);\r\n\t\t\t} else {\r\n\t\t\t\tthrow {\r\n\t\t\t\t\tmessage: \"unknow pin number\",\r\n\t\t\t\t\tpin: pin\r\n\t\t\t\t};\r\n\t\t\t}*/\r\n\t\t}\r\n\t};\r\n\t\r\n\tATMEGA328P.prototype.pinToPORT = function(pin) {\r\n\t\tvar self = this;\r\n\t\t\r\n\t\tpin = self.tryToConvert(pin, \"number\");\r\n\t\tif(pin instanceof VString) {\r\n\t\t\treturn new VString(\"*pinToPORT(\" + pin.toString() + \")\");\r\n\t\t} else {\r\n\t\t\tif((0 <= pin) && (pin < 8)) {\r\n\t\t\t\treturn \"PORTD\";\r\n\t\t\t} else if((8 <= pin) && (pin < 14)) {\r\n\t\t\t\treturn \"PORTB\";\r\n\t\t\t} else if((16 <= pin) && (pin < 22)) {\r\n\t\t\t\treturn \"PORTB\";\r\n\t\t\t} else {\r\n\t\t\t\tthrow {\r\n\t\t\t\t\tmessage: \"unknow pin number\",\r\n\t\t\t\t\tpin: pin\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t\r\n\tATMEGA328P.prototype.digitalWrite = function(pin, state) {\r\n\t\tvar self = this;\r\n\t\t\r\n\t\tstate = self.tryToConvert(state, \"bool\");\r\n\t\tif(state instanceof VString) {\r\n\t\t\treturn new VString(\r\n\t\t\t\t\"(\" + state.toString() + \" ? \" +\r\n\t\t\t\t\t\"(\" + self.pinToPORT(pin).toString() + \" |= \" + self.convertNumberToByte(self.pinToPORTMask(pin)).toString() + \")\" + \" : \" +\r\n\t\t\t\t\t\"(\" + self.pinToPORT(pin).toString() + \" &= \" + self.convertNumberToByte(self.invert(self.pinToPORTMask(pin))).toString() + \")\" +\r\n\t\t\t\t\")\"\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tif(state) {\r\n\t\t\t\treturn self.pinToPORT(pin).toString() + \" |= \" + self.convertNumberToByte(self.pinToPORTMask(pin)).toString() + \";\";\r\n\t\t\t} else {\r\n\t\t\t\treturn self.pinToPORT(pin).toString() + \" &= \" + self.convertNumberToByte(self.invert(self.pinToPORTMask(pin))).toString() + \";\";\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\tvar microcontroller = new ATMEGA328P();\r\n%>\r\n\r\n/*\r\nthree ways of writing the same function :\r\n\r\n\t\r\n\t<%= microcontroller.digitalWrite('D5', 'HIGH') %> // giving D5 constant as a string\r\n\t<%= microcontroller.digitalWrite(_const.pins.D5, 'HIGH') %> // giving D5 constant from the _const object\r\n\t<%= microcontroller.digitalWrite(5, 'HIGH') %> // giving number 5 \r\n*/\r\n\r\n<%\r\n\t// why UMPL is useful ? you'll see :\r\n\t\r\n\t\t// we define constants here and not in the C++ code\r\n\tvar ledPin\t= \"D13\";\r\n%>\r\n\r\n<%= microcontroller.getCPPFunctions() %>\r\n\r\n\r\n\t// the code inside of this function is strongly optimized\r\nvoid blink_fast() {\r\n\t<%= microcontroller.digitalWrite(ledPin, 'HIGH') %>\r\n\t<%= microcontroller.digitalWrite(ledPin, 'LOW') %>\r\n};\r\n\r\n\r\n#define LED_PIN 13\r\n\r\n\t// the code inside of this function is not optimized at the best because we use a C++ constant \r\nvoid blink_slow() {\r\n\t<%= microcontroller.digitalWrite(new VString('LED_PIN'), 'HIGH') %>\r\n\t<%= microcontroller.digitalWrite(new VString('LED_PIN'), 'LOW') %>\r\n};\r\n\r\n\t// the code inside of this function is the slowest, digitalWrite is provided by the Arduino IDE\r\nvoid blink_slower() {\r\n\tdigitalWrite(LED_PIN, HIGH);\r\n\tdigitalWrite(LED_PIN, LOW);\r\n};\r\n\r\n\r\nuint32_t time_0;\r\nuint32_t time_1;\r\n\r\nvoid setup() {\r\n\tSerial.begin(115200);\r\n\t\r\n\t<%\r\n\r\n\t\tvar exec_num = 100000;\r\n\t\t['blink_fast', 'blink_slow', 'blink_slower'].forEach(function(fnc) {\r\n\t\t\t%>\r\n\t\t\t\r\n\t\t\t\ttime_0 = micros();\r\n\t\t\t\tfor(uint32_t i = 0; i < <%= exec_num %>; i++) {\r\n\t\t\t\t\t<%= fnc %>();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ttime_1 = micros();\r\n\t\t\t\tSerial.print(\"<%= fnc %> takes \");\r\n\t\t\t\tSerial.print(((float) (time_1 - time_0)) / <%= exec_num %>, DEC);\r\n\t\t\t\tSerial.println(\" microseconds\");\r\n\t\t\t<%\r\n\t\t});\r\n\t%>\r\n}\r\n\r\n\r\nvoid loop() {\r\n\t\r\n}\r\n\r\n\r\n\t");