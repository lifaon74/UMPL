
/**
	Author : Valentin Richard
	License : totally free and open library, you can do anything you want with it.
	Description : this library gives you the ability to work with linked list.
**/


/**
 * LinkedNode
 *
 * Represent a node which can be chained with others,
 * the node hasn't any value, because the purpose is to extend another class with LinkedNode,
 * this way you can have any type of chained elements, and any type of linked lists (cyclic, linear, etc...)
 *
 * linked nodes form a cyclic list
 *
 * @property public next :LinkedNode		- the next LinkedNode
 * @property public previous :LinkedNode	- the previous LinkedNode
 *
 */

var LinkedNode = function() {
	this.next		= this;
	this.previous	= this;
};

	// [STATIC] link two nodes together : set node_1 as the next of node_0
LinkedNode.link = function(node_0, node_1) {
	node_0.next			= node_1;
	node_1.previous		= node_0;
	return LinkedNode;
}

/**
 * Insert <node> after current node
 *
 * @param :LinkedNode node
 * @returns :LinkedNode this
 */
LinkedNode.prototype.appendNext = function(node) {
	if(node !== this) {
		LinkedNode.link(node.previous, node.next); // properly detach the node
		LinkedNode.link(node, this.next);
		LinkedNode.link(this, node); // this -> node -> this.next
	}
	return this;
}

/**
 * Insert <node> before current node
 *
 * @param :LinkedNode node
 * @returns :LinkedNode this
 */
LinkedNode.prototype.appendPrevious = function(node) {
	return this.previous.appendNext(node);
}

/**
 * Detach current node from previous and next nodes
 *
 * @returns :LinkedNode this
 */
LinkedNode.prototype.detach = function() {
	if(!this.isDetached()) {
		LinkedNode.link(this.previous, this.next);
		LinkedNode.link(this, this);
	}
	return this;
}

/**
 * Returns true is current node is detached (has no previous or next nodes)
 *
 * @returns :boolean
 */
LinkedNode.prototype.isDetached = function() {
	return (this.next === this);
}

/**
 * Replace current node in a list by <node>
 *
 * @returns :LinkedNode this
 */
LinkedNode.prototype.replaceBy = function(node) {
	if((node !== this) && (!this.isDetached())) {
		LinkedNode.link(node.previous, node.next); // properly detach the node
		LinkedNode.link(this.previous, node);
		LinkedNode.link(node, this.next); // previous -> node -> next
		LinkedNode.link(this, this); // detach
	}
	
	return this;
}



/*
	Example: create a simple list composed of 3 nodes - node_0 -> node_1 -> node_2

	var node_0 = new LinkedNode();
	var node_1 = new LinkedNode();
	var node_2 = new LinkedNode();

 	node_0.appendNext(node_2); //  node_0 -> node_2
 	node_0.appendNext(node_1); //  node_0 -> node_1 -> node_2
*/



/**
 * LinkedNodeIterator
 *
 * An iterator start from a node and iterate until there's no more next node
 * It's some kind of for loop
 *
 * @params: node:LinkedNode - the node to start from
 */

LinkedNodeIterator = function(node) {
	this._originNode	= node;
	this._currentNode	= node;
}

/**
 * Returns true if iterator looped (all nodes inspected)
 *
 * @returns :boolean
 */
LinkedNodeIterator.prototype.looped = function() {
	return (this._currentNode === this._originNode);
}

/**
 * Jump to next node
 *
 * Returns true if there's more node to inspect
 *
 * @returns :boolean
 */
LinkedNodeIterator.prototype.next = function() {
	this._currentNode	= this._currentNode.next;
	return !this.looped();
}

/**
 * Jump to previous node
 *
 * Returns true if there's more node to inspect
 *
 * @returns :boolean
 */
LinkedNodeIterator.prototype.previous = function() {
	this._currentNode = this._currentNode.previous;
	return !this.looped();
}

/**
 * Returns current node
 *
 * @returns :LinkedNode
 */
LinkedNodeIterator.prototype.getNode = function() {
	return this._currentNode;
}

/**
 * Returns number of nodes in the list
 *
 * @returns :number
 */
LinkedNodeIterator.prototype.size = function() {
	var _size = 0;
	do { _size++; } while(this.next());
	return _size;
}

/**
 * Convert a linked list into a string
 *
 * @returns :string
 */
LinkedNodeIterator.prototype.toString = function() {
	var string		= "";
	var i			= 0;
	do {
		if(i > 0) { string += ", "; }
		string += this.getNode().toString();
		i++;
	} while(this.next());
	
	return string;
}

/*
	Example: simple for loop for our previous list - node_0 -> node_1 -> node_2

	var iterator = new LinkedNodeIterator(node_0);

 	do {
 		console.log(iterator.getNode());
	} while(iterator.next());

 */




/**
 * LinkedList
 *
 * Simply a list of LinkedNode
 */

LinkedList = function() {
	this._first	= null;
}


/**
 * Returns the first node of the list
 * If list size is 0, return null
 *
 * @returns :LinkedNode
 */
LinkedList.prototype.first = function() {
	return this._first;
}

/**
 * Returns the last node of the list
 * If list size is 0, return null
 *
 * @returns :LinkedNode
 */
LinkedList.prototype.last = function() {
	if(this._first === null) {
		return null;
	} else {
		return this._first.previous;
	}
}

/**
 * Return a LinkedNodeIterator for this list
 * If list size is 0, return null
 *
 * @returns :LinkedNodeIterator
 */
LinkedList.prototype.iterator = function() {
	if(this._first === null) {
		return null;
	} else {
		return new LinkedNodeIterator(this._first);
	}
}

/**
 * ForEach loop for the current list
 *
 * @params :function callback(node, index)
 * @returns :LinkedList this
 */
LinkedList.prototype.forEach = function(callback) {
	var it = this.iterator();
	if(it) {
		var i = 0;
		do {
			callback(it.getNode(), i);
			i++;
		} while(it.next());
	}
	return this;
};


/**
 * Clear the list
 *
 * @returns :LinkedList this
 */
LinkedList.prototype.clear = function() {
	this._first = null;
	return this;
}

/**
 * Insert <node_1> after <node_0>
 *
 * @param node_0
 * @param node_1
 * @returns :LinkedList this
 */
LinkedList.prototype.appendNext = function(node_0, node_1) {
	if(node_0 === null) { // insert at the beginning (equivalent of unshift)
		this.appendPrevious(this._first, node_1);
	} else {
		node_0.appendNext(node_1);
	}
	
	return this;
}

/**
 * Insert <node_1> before <node_0>
 *
 * @param node_0
 * @param node_1
 * @returns :LinkedList this
 */
LinkedList.prototype.appendPrevious = function(node_0, node_1) {
	if(node_0 === this._first) {
		if(this._first !== null) {
			this._first.appendPrevious(node_1);
		}
		
		this._first	= node_1;
	} else {
		node_0.appendPrevious(node_1);
	}
	
	return this;
}


/**
 * Remove <node> from the list
 * @param node
 * @returns :LinkedList this
 */

LinkedList.prototype.detach = function(node) {
	if(node === this._first) {
		if(node.isDetached()) {
			this._first = null;
		} else {
			this._first = node.next;
			node.detach();
		}
	} else {
		node.detach();
	}

	return this;
}

/**
 * Add <node> at the end of the list
 *
 * @param node
 * @returns :LinkedList this
 */
LinkedList.prototype.push = function(node) {
	return this.appendNext(this.last(), node);
}

/**
 * Remove last node of the list
 *
 * @returns :LinkedNode - last node
 */
LinkedList.prototype.pop = function() {
	return this.detach(this.last());
}

/**
 * Add <node> at the begining of the list
 *
 * @param node
 * @returns :LinkedList this
 */
LinkedList.prototype.shift = function(node) {
	return this.appendPrevious(this._first, node);
}


/**
 * Remove first node of the list
 *
 * @returns :LinkedNode - first node
 */
LinkedList.prototype.unshift = function(node) {
	return this.detach(this._first);
}

/**
 * Convert this linked list into a string
 *
 * @returns :string
 */
LinkedList.prototype.toString = function() {
	var str = "";
	var it = this.iterator();
	if(it) {
		do {
			str += it.getNode().toString() + ", ";
		} while(it.next());
	}
	return str;
};


/*
	Example: create a simple list composed of 3 nodes - node_0 -> node_1 -> node_2

	var node_0 = new LinkedNode();
	var node_1 = new LinkedNode();
	var node_2 = new LinkedNode();

	var linkedList = new LinkedList();
 	linkedList.push(node_0);
 	linkedList.push(node_1);
 	linkedList.push(node_2);

	linkedList.forEach(function(node, index) {
		console.log(node, index);
	});


 */



if(typeof module != 'undefined') {
	module.exports = {
		LinkedList: LinkedList,
		LinkedNodeIterator: LinkedNodeIterator,
		LinkedNode: LinkedNode
	};
}








