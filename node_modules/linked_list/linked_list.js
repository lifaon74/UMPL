
/*
	Author : Valentin Richard
	License : totally free and open library, you can do anything you want with it.
	Description : this library gives you the ability to work with linked list.
*/

/**
	LinkedNode
**/

/*var LinkedNode = function(value) {
	if(typeof value == "undefined") { var value = null; }
	
	this.next		= this;
	this.previous	= this;
	
	this.value		= value;
}*/

var LinkedNode = function() {
	this.next		= this;
	this.previous	= this;
};

	// link two nodes together : set node_1 as the next of node_0
LinkedNode.link = function(node_0, node_1) {
	node_0.next			= node_1;
	node_1.previous		= node_0;
	return LinkedNode;
}



/*LinkedNode.prototype.setValue = function(value) {
	this.value = value;
	return this;
}

LinkedNode.prototype.getValue = function() {
	return this.value;
}*/


LinkedNode.prototype.appendNext = function(node) {
	if(node !== this) {
		LinkedNode.link(node.previous, node.next); // properly detach the node
		LinkedNode.link(node, this.next);
		LinkedNode.link(this, node); // this -> node -> this.next
	}
	
	return this;
}

LinkedNode.prototype.appendPrevious = function(node) {
	return this.previous.appendNext(node);
}

LinkedNode.prototype.detach = function() {
	if(!this.isDetached()) {
		LinkedNode.link(this.previous, this.next);
		LinkedNode.link(this, this);
	}
	return this;
}

LinkedNode.prototype.isDetached = function() {
	return (this.next === this);
}

LinkedNode.prototype.replaceBy = function(node) {
	if((node !== this) && (!this.isDetached())) {
		LinkedNode.link(node.previous, node.next); // properly detach the node
		LinkedNode.link(this.previous, node);
		LinkedNode.link(node, this.next); // previous -> node -> next
		LinkedNode.link(this, this);
	}
	
	return this;
}

/*LinkedNode.prototype.toString = function() {
	return this.value.toString();
}*/

/*LinkedNode.prototype._makeNode = function(node) {
	if(node instanceof LinkedNode) {
		return  node;
	} else {
		return new LinkedNode(node);
	}
}*/




/**
	LinkedNodeIterator
**/

LinkedNodeIterator = function(node) {
	this._originNode	= node;
	this._currentNode	= node;
}

LinkedNodeIterator.prototype.looped = function() {
	return (this._currentNode === this._originNode);
}

LinkedNodeIterator.prototype.next = function() {
	this._currentNode	= this._currentNode.next;
	return !this.looped();
}

LinkedNodeIterator.prototype.previous = function() {
	this._currentNode = this._currentNode.previous;
	return !this.looped();
}

LinkedNodeIterator.prototype.getNode = function() {
	return this._currentNode;
}

LinkedNodeIterator.prototype.size = function() {
	var _size = 0;
	do { _size++; } while(this.next());
	return _size;
}

LinkedNodeIterator.prototype.toString = function() {
	var string		= "";
	var i			= 0;
	do {
		if(i > 0) { string += ", "; }
		string += this.getNode().toString();
		i++;
	} while(this.next());
	
	return string;
}


/**
	LinkedList
**/

LinkedList = function() {
	this._first	= null;
}

LinkedList.prototype.first = function() {
	return this._first;
}

LinkedList.prototype.last = function() {
	if(this._first === null) {
		return null;
	} else {
		return this._first.previous;
	}
}

LinkedList.prototype.iterator = function() {
	if(this._first === null) {
		return null;
	} else {
		return new LinkedNodeIterator(this._first);
	}
}

LinkedList.prototype.forEach = function(callback) {
	var it = this.iterator();
	if(it) {
		do {
			callback(it.getNode());
		} while(it.next());
	}
};



LinkedList.prototype.clear = function() {
	this._first = null;
}


LinkedList.prototype.appendNext = function(node_0, node_1) {
	if(node_0 === null) { // insert at the beginning (equivalent of unshift)
		this.appendPrevious(this._first, node_1);
	} else {
		node_0.appendNext(node_1);
	}
	
	return this;
}

LinkedList.prototype.appendPrevious = function(node_0, node_1) {
	if(node_0 === this._first) {
		if(this._first !== null) {
			this._first.appendPrevious(node_1);
		}
		
		this._first	= node_1;
	} else {
		node_0.appendPrevious(node_1);
	}
	
	return this;
}

LinkedList.prototype.detach = function(node) {
	if(node === this._first) {
		if(node.isDetached()) {
			this._first = null;
		} else {
			this._first = node.next;
			node.detach();
		}
	} else {
		node.detach();
	}
	
	
	return this;
}


LinkedList.prototype.push = function(node) {
	return this.appendNext(this.last(), node);
}

LinkedList.prototype.pop = function() {
	return this.detach(this.last());
}

LinkedList.prototype.shift = function(node) {
	return this.appendPrevious(this._first, node);
}

LinkedList.prototype.unshift = function(node) {
	return this.detach(this._first);
}

LinkedList.prototype.toString = function() {
	var str = "";
	var it = this.iterator();
	if(it) {
		do {
			str += it.getNode().toString() + ", ";
		} while(it.next());
	}
	return str;
};

module.exports = {
  LinkedList: LinkedList,
  LinkedNodeIterator: LinkedNodeIterator,
  LinkedNode: LinkedNode
};








