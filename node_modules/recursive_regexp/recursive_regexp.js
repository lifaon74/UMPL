

try {
    var VisibilityString = require('visibility_string').VisibilityString;
} catch(error) {
    var VisibilityString = function() {};
}



/***
	RegExpMatch: 
		Description: 	
			represent a match result returned by RegExp.match
		
		Attributes :
			@matchString	: the matched string
			@position		: object containing the start and end index of the match
			@variables		: array containing the variables obtained for this match
***/

var RegExpMatch = function(matchString, index) {
	this.matchString	= matchString;
	this.position		= {
		"start"	: index,
		"end"	: index + this.matchString.length
	};
	this.variables		= [];
}


/***
	Define some useful shortcuts
***/

	// close to \s
RegExp.whiteChar	= '[ \\n\\r\\t]';
RegExp._whiteChar	= '[^ \\n\\r\\t]';

	// close to \w
RegExp.word		= '[a-zA-Z]';
RegExp._word		= '[^a-zA-Z]';

RegExp.anything	= '[^]'; // .|\\n|\\r    -    \\w|\\W   -    [^]

RegExp.dont_capture = function(string) {
	return "(?:" + string + ")";
}


function _prepareRegExpToQuote() {
		// quote
	var escapeChar = ['\\', '.', '$', '[', ']', '(', ')', '{', '}', '^', '?', '!', '=', '*', '#', ':', '+', '-'];
	var quoteRegExp = '';
	
	for(var i = 0; i < escapeChar.length; i++) {
		if(i > 0) { quoteRegExp += '|'; }
		quoteRegExp += '\\' + escapeChar[i];
	}
	
	RegExp.quoteRegExp = new RegExp('(' + quoteRegExp + ')', 'gi');
}; _prepareRegExpToQuote();

	// escape special chars
RegExp.quote = function(string) {
	return string.replace(this.quoteRegExp, '\\$1');
}


	// if set to true, the next match will not start at the end of the previous result, but at its beginning
	// ex: /<</g.match("<<<") will return two results instead of one
RegExp.prototype.deepInspection			= false;
RegExp.prototype.visibilityStringIndex	= 0;



/***
	RegExp.match: 
		Description: 
			search the next occurrence according to the regexp pattern for a specific string
		
		Arguments :
			@string	(String) | (VisibilityString) : the string where we want to find the pattern
			
		Return :
			(RegExpMatch) or null
***/

RegExp.prototype.match = function(string) {
	var match = null;
	
	if(string instanceof VisibilityString) {
		var visibilityStringsIndexed	= string.getVisibleStrings();
		var visibilityStringIndexed;
		
		while(this.visibilityStringIndex < visibilityStringsIndexed.length) {
			visibilityStringIndexed = visibilityStringsIndexed[this.visibilityStringIndex];
			
			if(match = this.match(visibilityStringIndexed.string)) {
				match.position.start	= visibilityStringIndexed.indexes[match.position.start];
					// <match.position.end> is after the end char, so we need to take the end char and add 1 to it
				match.position.end		= visibilityStringIndexed.indexes[match.position.end - 1] + 1;
				break;
			} else {
				this.visibilityStringIndex++;
				if(this.visibilityStringIndex >= visibilityStringsIndexed.length) {
					this.visibilityStringIndex = 0;
					break;
				}
			}
		}
	} else {
		
		var _match = this.exec(string);
		if(_match) {
			match = new RegExpMatch(_match[0], _match.index);
			for(var i = 1; i < _match.length; i++) {
				match.variables.push(_match[i]);
			}
			
			if(this.deepInspection) { this.setStartIndex(_match.index + 1); }
		}
	}	
		
	return match;
}


/***
	RegExp.matchAll: 
		Description: 
			search all the occurrences according to the regexp pattern for a specific string
		
		Arguments :
			@string	(String) | (VisibilityString) : the string where we want to find the pattern
			
		Return :
			[(RegExpMatch), ...] : array of (RegExpMatch)
***/

RegExp.prototype.matchAll = function(string) {
	var matches = [];
	var match;
	while(match = this.match(string)) {
		matches.push(match);
	}
	return matches;
}


/***
	RegExp.replace: 
		Description: 
			replace all the occurrences according to the regexp pattern for a specific string
		
		Arguments :
			@string	(String) : the string where we want to replace elements
			@replacement (String) | (Function) : the replacement pattern.
				If (Function) :
					Arguments : 
						@match (RegExpMatch)
					Return :
						(String) : the replacement pattern
					
			
		Return :
			(String) : the new string
***/

RegExp.prototype.replace = function(string, replacement) {
	if(replacement instanceof Function) {
		var replacement_copy = replacement;
		replacement = function() {
			var length = arguments.length;
			var match = new RegExpMatch(arguments[0], arguments[length - 2]);
			
			for(var i = 1; i < length - 2; i++) {
				match.variables.push(arguments[i]);
			}
			
			return replacement_copy(match);
		};
	}
		
	return string.replace(this, replacement);
}


/***
	RegExp.setStartIndex: 
		Description: 
			define the index where the regex must start
		
		Arguments :
			@index	(Number) : the index
			[OPT] @visibilityStringIndex (Number) : the index for the (VisibilityString)
***/

RegExp.prototype.setStartIndex = function(index, visibilityStringIndex) {
	this.lastIndex = index;
	if(typeof visibilityStringIndex != 'undefined') {
		this.visibilityStringIndex = visibilityStringIndex;
	}
}

/***
	RegExp.reset: 
		Description: 
			reset the start index
***/

RegExp.prototype.reset = function() {
	this.setStartIndex(0, 0);
}


	
	
var RecursiveRegExpMatch = function(start, end) {
	this.start	= start;
	this.end	= end;
}

var RecursiveRegExp = function(startPattern, startFlags, endPattern, endFlags) {
	this.startPattern	= startPattern;
	this.startFlags		= startFlags;
	this.endFlags		= endFlags;
	
	this.startRegExp	= new RegExp(this.startPattern, this.startFlags);
	
	
	if(endPattern instanceof Function) {
		this.endPattern		= endPattern;
	} else {
		var endVarRegExp	= new RegExp("(^|[^\\\\])\\$([0-9]+)", "g");
		this.endPattern = function(matchForStartPattern) {
			return endVarRegExp.replace(endPattern, function(matchForEnd) {
				return matchForEnd.variables[0] + matchForStartPattern.variables[matchForEnd.variables[1] - 1];
			});
		}
	}
}

	/*
		if greedy :
			we search for the first startPattern, we complete it by searching for the last endPattern, etc...
		else
			we search for the last startPattern, we complete it by searching for the first endPattern, etc...
	*/
RecursiveRegExp.prototype.matchAll = function(string, greedy) {
	if(typeof greedy == "undefined") { var greedy = false; }
	
	var matches = [];
	var startMatchesOrderedByEndPattern = [];
	
	var matchesForStartPattern;
	var matchForStartPattern;
	var matchForEndPattern;
	var startIndex;
	var endIndex;
	var endRegExp;
	var size;
	
	var endPattern;
	
	while(matchForStartPattern = this.startRegExp.match(string)) {
		endPattern = this.endPattern(matchForStartPattern);
		if(typeof endPattern == "string") {
			if(typeof startMatchesOrderedByEndPattern[endPattern] == "undefined") {
				startMatchesOrderedByEndPattern[endPattern] = [];
			}
			startMatchesOrderedByEndPattern[endPattern].push(matchForStartPattern);
		}
	}
	
	//console.log(startMatchesOrderedByEndPattern);
	
	for(endPattern in startMatchesOrderedByEndPattern) {
		matchesForStartPattern = startMatchesOrderedByEndPattern[endPattern];
		endRegExp = new RegExp(endPattern, this.endFlags);
			
		if(greedy) {
			var matchesForEndPattern = [];
			while(matchForEndPattern = endRegExp.match(string)) {
				matchesForEndPattern.push(matchForEndPattern);
			}
			
			
			size = Math.max(matchesForStartPattern.length, matchesForEndPattern.length);
			var j = -1;
			var k = matchesForEndPattern.length;
			
			for(var i = 0; i < size; i++) {
				j++;
				k--;
				
				if(typeof matchesForStartPattern[j] == "undefined") {
					matches.push(new RecursiveRegExpMatch(null, matchesForEndPattern[k]));
					continue;
				} else {
					matchForStartPattern = matchesForStartPattern[j];
				}
				
				if(typeof matchesForEndPattern[k] == "undefined") {
					matches.push(new RecursiveRegExpMatch(matchesForStartPattern[j], null));
					continue;
				} else {
					matchForEndPattern = matchesForEndPattern[k];
				}
				
				if(matchForStartPattern.position.end < matchForEndPattern.position.end) {
					matches.push(new RecursiveRegExpMatch(matchForStartPattern, matchForEndPattern));
				} else {
					matches.push(new RecursiveRegExpMatch(matchForStartPattern, null));
					matches.push(new RecursiveRegExpMatch(null, matchForEndPattern));
				}
				
				
			}
			
		} else {
			while(matchForEndPattern = endRegExp.match(string)) {
				endIndex = matchForEndPattern.position.start;
				for(var i = matchesForStartPattern.length - 1; i >= 0; i--) {
					matchForStartPattern = matchesForStartPattern[i];
					if(matchForStartPattern != null) {
						startIndex = matchForStartPattern.position.end;
						//console.log(startIndex);
						if(startIndex < endIndex) {
							matches.push(new RecursiveRegExpMatch(matchForStartPattern, matchForEndPattern));
							matchesForStartPattern[i] = null;
							break;
						}
					}
				}
				
					// no matchForStartPattern found for this matchForEndPattern
				if(i < 0) {
					matches.push(new RecursiveRegExpMatch(null, matchForEndPattern));
				}
			}
			
				// no matchForEndPattern found for this matchForStartPattern
			for(var i = 0; i < matchesForStartPattern.length; i++) {
				matchForStartPattern = matchesForStartPattern[i];
				if(matchForStartPattern != null) {
					matches.push(new RecursiveRegExpMatch(matchForStartPattern, null));
				}
			}
		}
	}
	
	return matches;
}
	
module.exports = {
  RegExp: RegExp,
  RecursiveRegExp: RecursiveRegExp
};




















