/**
 * VisibilityString
 *
 * Represent a string in which each char can have a specific visibility.
 * Works with <regexp_utils>
 * Realy usefull in syntax analasys, you can specify if some chars should be excluded from match search or not.
 *
 */


var VisibilityStringInterval = function(start, end, visibility) {
	this.start			= start;
	this.end			= end;
	this.visibility		= visibility;
}

var VisibilityStringIndexed = function() {
	this.string		= "";
	this.indexes	= [];
}


VisibilityStringInterval.prototype.getString = function(visibilityString) {
	return visibilityString.string.slice(this.start, this.end);
}

	
	
var VisibilityString = function(string) {
	this.string		= string;
	this.length		= string.length;
	this.visibility	= new Uint8Array(this.length);
	this.start		= 0;
	this.end		= 0;
	this.resetAvailableInterval();
	
	this.visibilityIntervalNeedUpdate	= true;
	this.visibilityInterval				= [];
	
	this.visibleStringsNeedUpdate	= true;
	this.visibleStrings				= [];
	
	this.setVisibility(VisibilityString.visible);
	this.getVisibility();
}

VisibilityString.visible		= 0; // the portion will be read normaly
VisibilityString.transparent	= 1; // the portion will be considered as existing but will not output anything
VisibilityString.invisible		= 2; // the portion will not exist

VisibilityString.prototype.setVisibility = function(start, end, visibility) {
	for(var i = start; i < end; i++) {
		this.visibility[i] = visibility;
	}
	
	this.visibilityIntervalNeedUpdate	= true;
	this.visibleStringsNeedUpdate	= true;
	return this;
}

	// TODO : add support of available interval
VisibilityString.prototype.getVisibility = function() {
	if(this.visibilityIntervalNeedUpdate) {
		var lastVisibilityInterval = new VisibilityStringInterval(0, 0, this.visibility[0]);
		this.visibilityInterval  = [lastVisibilityInterval];
		
		for(var i = 1; i < this.length; i++) {
			var _visibility = this.visibility[i];
			if(_visibility != lastVisibilityInterval.visibility) {
				lastVisibilityInterval.end = i;
				lastVisibilityInterval = new VisibilityStringInterval(i, 0, _visibility);
				this.visibilityInterval.push(lastVisibilityInterval);
			}
		}
		
		lastVisibilityInterval.end = this.length;
		this.visibilityIntervalNeedUpdate = false;
	}
	
	return  this.visibilityInterval;
}

VisibilityString.prototype.getVisibleStrings = function() {
	if(this.visibleStringsNeedUpdate) {
		var visibilityStringIndexed = null;
		this.visibleStrings  = [];
		
		for(var i = this.start; i < this.end; i++) {
			switch(this.visibility[i]) {
				case VisibilityString.visible:
					if(visibilityStringIndexed == null) {
						visibilityStringIndexed = new VisibilityStringIndexed();
						this.visibleStrings.push(visibilityStringIndexed);
					}
					
					visibilityStringIndexed.string += this.string[i];
					visibilityStringIndexed.indexes.push(i);
				break;
				case VisibilityString.transparent:
					visibilityStringIndexed = null;
				break;
				case VisibilityString.invisible:
				break;
			}
		}
		
		this.visibleStringsNeedUpdate = false;
	}
	
	return  this.visibleStrings;
}

VisibilityString.prototype.setAvailableInterval = function(start, end) {
	this.start		= start;
	this.end		= end;
	return this;
}

VisibilityString.prototype.resetAvailableInterval = function() {
	this.setAvailableInterval(0, this.length);
	return this;
};


VisibilityString.prototype.slice = function(start, end, visibilyLevel) {
	if(typeof visibilyLevel == 'undefined') {
		var visibilyLevel = 0;
	}
	
	var string = "";
	
	start	= Math.max(start, this.start);
	end		= Math.min(end, this.end);
	
	for(var i = start; i < end; i++) {
		if(this.visibility[i] <= visibilyLevel) {
			string += this.string[i];
		}
	}
	
	return string;
};

module.exports = {
  VisibilityString: VisibilityString
};