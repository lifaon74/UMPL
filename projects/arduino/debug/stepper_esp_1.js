$buffer.push("\r\n\r\n");
	var stepPin	= "D10";
	var enPin	= "D12";
	var dirPin	= "D11";
	
	var number_of_stepper_drivers = 8;
	var precision = 32;
	var last_bit_mask = Math.pow(2, precision - 1);
	
	var CPP = {};
	
	CPP.toHex = function(number) {
		return new VString("0x" + number.toString(16));
	};
	
	CPP.toType = function(number, type) {
		switch(type) {
			case 'uint8_t':
				return number & 0xFF;
			break;
			case 'uint16_t':
				return number & 0xFFFF;
			break;
			case 'uint32_t':
				return number & 0xFFFFFFFF;
			break;
			case 'uint64_t':
				return number & 0xFFFFFFFFFFFFFFFF;
			break;
		}
	};
	
	CPP.invert = function(number) {
		if(_.isNumber(number)) {
			return (~number);
		} else if(number instanceof VString) {
			return new VString("~(" + number.toString() + ")");
		} else {
			throw {
				message: "unknow number type",
				number: number
			};
		}
	};
$buffer.push("\r\n\r\n#define MOV_ACCEL 1\r\n#define MOV_DECCEL 2\r\n#define MOV_LINEAR 3\r\n\r\n\r\n\r\n\r\nclass Movement {\r\n\tpublic:\r\n\t\tuint16_t nb_ticks;\r\n\t\tuint16_t ticks;\r\n\t\tuint16_t nb_steps;\r\n\t\tuint16_t steps;\r\n\t\tuint8_t type;\r\n\t\t\r\n\t\tint" + ( precision.toString()));$buffer.push("_t acceleration;\r\n\t\tuint" + ( precision.toString()));$buffer.push("_t velocity;\r\n\t\tuint" + ( precision.toString()));$buffer.push("_t position;\r\n\t\r\n\t\tMovement();\r\n\t\t\r\n\t\tvoid \t\tset(uint16_t _nb_ticks, uint16_t _nb_steps, uint8_t _type);\r\n\t\tboolean \tcomplete();\r\n\t\tboolean\t\ttick();\r\n};\r\n\r\nMovement::Movement() {\r\n\tMovement::nb_ticks\t= 0;\r\n\tMovement::ticks\t\t= 0;\r\n\tMovement::nb_steps\t= 0;\r\n\tMovement::steps\t\t= 0;\r\n};\r\n\r\nvoid Movement::set(uint16_t _nb_ticks, uint16_t _nb_steps, uint8_t _type) {\r\n\tMovement::nb_ticks\t= _nb_ticks;\r\n\tMovement::ticks\t\t= 0;\r\n\tMovement::nb_steps\t= _nb_steps;\r\n\tMovement::steps\t\t= 0;\r\n\tMovement::type\t\t= _type;\r\n\t\r\n\tdouble f;\r\n\tswitch(Movement::type) {\r\n\t\tcase MOV_ACCEL:\r\n\t\tcase MOV_DECCEL:\r\n\t\t\tf = (((double) Movement::nb_steps) * 2.0) / (((double) Movement::nb_ticks) * ((double) Movement::nb_ticks));\r\n\t\t\tMovement::acceleration = (int" + ( precision.toString()));$buffer.push("_t) floor(f * pow(2, " + ( precision - 1));$buffer.push("));\r\n\t\tbreak;\r\n\t\tcase MOV_LINEAR:\r\n\t\t\tMovement::acceleration = 0;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tswitch(Movement::type) {\r\n\t\tcase MOV_ACCEL:\r\n\t\t\tMovement::velocity = Movement::acceleration >> 1;\r\n\t\tbreak;\r\n\t\tcase MOV_DECCEL:\r\n\t\t\tMovement::velocity = Movement::acceleration * ((uint" + ( precision.toString()));$buffer.push("_t) Movement::nb_ticks) - (Movement::acceleration >> 1);\r\n\t\t\tMovement::acceleration = -Movement::acceleration;\r\n\t\tbreak;\r\n\t\tcase MOV_LINEAR:\r\n\t\t\tf = ((double) Movement::nb_steps) / ((double) Movement::nb_ticks);\r\n\t\t\tMovement::velocity = (uint" + ( precision.toString()));$buffer.push("_t) floor(f * pow(2, " + ( precision - 1));$buffer.push("));\r\n\t\tbreak;\r\n\t}\r\n\t\r\n\tMovement::position = 0;\r\n\t\r\n\tSerial.print(\"a: \");\r\n\tSerial.print(Movement::acceleration, DEC);\r\n\t\r\n\tSerial.print(\" - v: \");\r\n\tSerial.print(Movement::velocity, DEC);\r\n\tSerial.println();\r\n};\r\n\r\nboolean Movement::complete() {\r\n\treturn (Movement::steps == Movement::nb_steps);\r\n};\r\n\r\n\t// return true if we need to step\r\nboolean\tMovement::tick() {\r\n\tif(Movement::ticks < Movement::nb_ticks) {\r\n\t\tMovement::ticks++;\r\n\t\tMovement::position += Movement::velocity;\r\n\t\tMovement::velocity += Movement::acceleration;\r\n\t\t\r\n\t\tif(Movement::position & " + ( CPP.toHex(last_bit_mask)));$buffer.push(") {\r\n\t\t\tMovement::position &= " + ( CPP.toHex(CPP.toType(CPP.invert(last_bit_mask), 'uint' + precision + '_t'))));$buffer.push(";\r\n\t\t\tMovement::steps++;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// else\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tMovement::steps++;\r\n\treturn true;\r\n};\r\n\r\n\r\nclass MovementsSync {\r\n\tpublic:\r\n\t\tMovement movements[" + ( number_of_stepper_drivers));$buffer.push("];\r\n\t\tuint16_t nb_ticks;\r\n\t\tuint8_t type;\r\n\t\t\r\n\t\tMovementsSync();\r\n\t\t\r\n\t\tvoid prepare(uint16_t _nb_ticks, uint8_t _type);\r\n\t\tvoid setSteps(uint8_t index, uint16_t nb_steps);\r\n\t\t\r\n\t\tboolean complete();\r\n\t\tuint8_t tick();\r\n};\r\n\r\nMovementsSync::MovementsSync() {\r\n};\r\n\r\nvoid MovementsSync::prepare(uint16_t _nb_ticks, uint8_t _type) {\r\n\tMovementsSync::nb_ticks\t= _nb_ticks;\r\n\tMovementsSync::type\t\t= _type;\r\n}\r\n\r\nvoid MovementsSync::setSteps(uint8_t index, uint16_t nb_steps) {\r\n\t// MovementsSync::movements[index].set(Movements::nb_ticks, nb_steps, Movements::type);\r\n\t// MovementsSync::_type\t= _type;\r\n}\r\n\r\nboolean MovementsSync::complete() {\r\n\tuint8_t i = " + ( number_of_stepper_drivers));$buffer.push(";\r\n\twhile(i-- > 0) {\r\n\t\tif(!(MovementsSync::movements[i].complete())) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n};\r\n\r\n\t// return mask of steps to do\r\nuint8_t MovementsSync::tick() {\r\n\tuint8_t mask;\r\n\tMovement * mov;\r\n\t\r\n\tuint8_t i = " + ( number_of_stepper_drivers));$buffer.push(";\r\n\twhile(i-- > 0) {\r\n\t\tmov = &(MovementsSync::movements[i]);\r\n\t\tif(!(mov->complete())) {\r\n\t\t\tif(mov->tick()) {\r\n\t\t\t\tmask |= (1 << i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn mask;\r\n};\r\n\r\n\r\nMovementsSync movements[5];\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*void ICACHE_RAM_ATTR timer_test_isr() {\r\n\t\r\n}\r\n\r\nvoid timer_test() {\r\n\tSerial.print(\"timer\");\r\n\ttimer1_disable();\r\n\ttimer1_attachInterrupt(timer_test_isr);\r\n\ttimer1_enable(TIM_DIV1, TIM_EDGE, TIM_LOOP); // TIM_SINGLE\r\n\ttimer1_write(2000);\r\n}*/\r\n\r\n\t\r\nuint8_t get_offset(uint16_t number) {\r\n\tuint8_t i = 0;\r\n\twhile(number >> (i++));\r\n\treturn i - 2;\r\n}\r\n\r\nvoid speed_test() {\r\n\tuint32_t t1, t2;\r\n\tuint16_t i;\r\n\t\r\n\tvolatile double a = 0;\r\n\tvolatile double b = 10000;\r\n\t\r\n\tuint8_t j;\r\n\t\r\n\t// ESP\r\n\t// a += a + b; : 2005\r\n\t// a += a - b; : 2005\r\n\t// a += a * b; : 2253\r\n\t// a += a / b; : 12754\r\n\t// a += a % b; : 15049\r\n\t// a += a >> b; : 2005\r\n\t// a += a << b; : 2003\r\n\t// a += a & b; : 1878\r\n\t// a += a | b; : 2005\r\n\t// a += a ^ b; : 1881\r\n\t// digitalWrite(a, b); : 10002\r\n\r\n\t// float:\r\n\t// a += a + b; : 9175\r\n\t// a += a - b; : 9127\r\n\t// a += a * b; : 11881\r\n\t// a += a / b; : 9378\r\n\t\r\n\t// double\r\n\t// a += a + b; : 11486\r\n\t// a += a - b; : 11129\r\n\t// a += a * b; : 13882\r\n\t// a += a / b; : 11379\r\n\r\n\r\n\t");[
		'a += a + b;',
		'a += a - b;',
		'a += a * b;',
		'a += a / b;'/*,
		'a += a % b;',
		'a += a >> b;',
		'a += a << b;',
		'a += a & b;',
		'a += a | b;',
		'a += a ^ b;',
		'digitalWrite(a, b);'*/
	].forEach(function(value) {
	$buffer.push("\r\n\t\t\tt1 = micros();\r\n\t\t\ti = 10000;\r\n\t\t\twhile(i-- > 0) {\r\n\t\t\t\t" + ( value));$buffer.push("\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tt2 = micros();\r\n\t\t\tSerial.print(\"" + ( value));$buffer.push(" : \");\r\n\t\t\tSerial.println(t2 - t1, DEC);\r\n\t\t");
	});
$buffer.push("\r\n\r\n\tSerial.println(a, DEC);\r\n}\r\n\r\n\r\n\r\nvoid step() {\r\n\tdigitalWrite(13, HIGH);\r\n\tdelayMicroseconds(5);\r\n\tdigitalWrite(13, LOW);\r\n\tdelayMicroseconds(5);\r\n}\r\n\r\nvoid _move(uint16_t nb_ticks, uint16_t steps, uint8_t movement) {\r\n\tdouble f = 0;\r\n\tint" + ( precision.toString()));$buffer.push("_t a;\r\n\tuint" + ( precision.toString()));$buffer.push("_t v, d;\r\n\t\r\n\tswitch(movement) {\r\n\t\tcase MOV_ACCEL: // 0.1391000003\r\n\t\tcase MOV_DECCEL:\r\n\t\t\tf = (steps * 2.0) / (nb_ticks * nb_ticks);\r\n\t\t\ta = (int" + ( precision.toString()));$buffer.push("_t) floor(f * pow(2, " + ( precision - 1));$buffer.push("));\r\n\t\tbreak;\r\n\t\tcase MOV_LINEAR:\r\n\t\t\ta = 0;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tswitch(movement) {\r\n\t\tcase MOV_ACCEL:\r\n\t\t\tv = a >> 1;\r\n\t\tbreak;\r\n\t\tcase MOV_DECCEL:\r\n\t\t\tv = a * ((uint32_t) nb_ticks) - (a >> 1);\r\n\t\t\ta = -a;\r\n\t\tbreak;\r\n\t\tcase MOV_LINEAR:\r\n\t\t\tf = ((double) steps) / ((double) nb_ticks);\r\n\t\t\tv = (uint" + ( precision.toString()));$buffer.push("_t) floor(f * pow(2, " + ( precision - 1));$buffer.push("));\r\n\t\tbreak;\r\n\t}\r\n\t\r\n\tSerial.print(\"a: \");\r\n\tSerial.print(a, DEC);\r\n\t\r\n\tSerial.print(\" - v: \");\r\n\tSerial.print(v, DEC);\r\n\tSerial.println();\r\n\t\r\n\td = 0;\r\n\t\r\n\tuint16_t i = nb_ticks;\r\n\tuint16_t nb_steps_done = 0;\r\n\t\r\n\tMovement mov;\r\n\tmov.set(10000, 1000, MOV_ACCEL);\r\n\t\r\n\tuint32_t t1 = micros();\r\n\twhile(i-- > 0) {\r\n\t\tif(mov.tick()) {\r\n\t\t\tnb_steps_done++;\r\n\t\t}\r\n\t\t// d += v;\r\n\t\t// if(d & " + ( CPP.toHex(last_bit_mask)));$buffer.push(") {\r\n\t\t\t// d &= " + ( CPP.toHex(CPP.toType(CPP.invert(last_bit_mask), 'uint' + precision + '_t'))));$buffer.push(";\r\n\t\t\t// nb_steps_done++;\r\n\t\t// }\r\n\t\t// v += a;\r\n\t}\r\n\t\r\n\tuint32_t t2 = micros();\r\n\t\r\n\tSerial.print(\"time: \");\r\n\tSerial.println(((float) (t2 - t1)) / ((float) nb_ticks), DEC);\r\n\tSerial.print(nb_ticks, DEC);\r\n\tSerial.print(\" - nb_ticks : \");\r\n\tSerial.print(steps, DEC);\r\n\tSerial.print(\" - nb_steps_done: \");\r\n\tSerial.println(nb_steps_done, DEC);\r\n\tSerial.print(\" - d: \");\r\n\tSerial.println(d, DEC);\r\n\tSerial.print(\" - v: \");\r\n\tSerial.print(v, DEC);\r\n\tSerial.println();\r\n}\r\n\r\nvoid _move2(double nb_ticks, double steps, uint8_t movement) {\r\n\tdouble a, v, t, d, f, nb_steps_done;\r\n\ta = v = t = d = f = nb_steps_done = 0; // v is not speed\r\n\t\r\n\t// we start at t = 1, so v = a and d = a / 2;\r\n\tswitch(movement) {\r\n\t\tcase MOV_ACCEL:\r\n\t\t\ta = (steps * 2.0) / (nb_ticks * nb_ticks);\r\n\t\t\tv = a / 2.0;\r\n\t\tbreak;\r\n\t\tcase MOV_DECCEL:\r\n\t\t\ta = (steps * 2.0) / (nb_ticks * nb_ticks);\r\n\t\t\tv = (nb_ticks - 0.5) * a;\r\n\t\t\ta = -a;\r\n\t\tbreak;\r\n\t\tcase MOV_LINEAR:\r\n\t\t\ta = 0.0;\r\n\t\t\tv = steps / nb_ticks;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tSerial.println(v, DEC);\r\n\t\r\n\tf = a / 2.0;\r\n\t\r\n\tuint32_t t1 = micros();\r\n\tnb_steps_done = 0;\r\n\t// for(t = 1.0; t <= nb_ticks; t++) { // 7.4677000046\r\n\t\t// d = f * t * t;\r\n\t\t// if((d - nb_steps_done) >= 1) {\r\n\t\t\t// nb_steps_done = floor(d);\r\n\t\t// }\r\n\t// }\r\n\t\r\n\tuint16_t j = nb_ticks;\r\n\tfor(uint16_t i = 0; i < j; i++) { // 4.3702001572\r\n\t\td += v;\r\n\t\tif((d - nb_steps_done) >= 1) {\r\n\t\t\tnb_steps_done++;\r\n\t\t}\r\n\t\tv += a;\r\n\t}\r\n\t\r\n\t// uint16_t j = nb_ticks;\r\n\t\r\n\t// uint32_t _a = (int32_t) floor(a * pow(2, 31));\r\n\t// uint32_t _v = _a >> 1;\r\n\t// uint32_t _d = 0;\r\n\t// for(uint16_t i = 0; i < j; i++) { // 4.3702001572\r\n\t\t// _d += _v;\r\n\t\t// if(_d & 0x80000000) {\r\n\t\t\t// _d &= 0x7FFFFFFF;\r\n\t\t\t// nb_steps_done++;\r\n\t\t// }\r\n\t\t// _v += _a;\r\n\t// }\r\n\t\r\n\tuint32_t t2 = micros();\r\n\t\r\n\tSerial.print(\"time: \");\r\n\tSerial.println(((float) (t2 - t1)) / ((float) nb_ticks), DEC);\r\n\tSerial.print(nb_ticks, DEC);\r\n\tSerial.print(\" - \");\r\n\tSerial.print(steps, DEC);\r\n\tSerial.print(\" - \");\r\n\tSerial.println(nb_steps_done, DEC);\r\n\tSerial.print(\" - d: \");\r\n\tSerial.println(d, DEC);\r\n\tSerial.print(\" - v: \");\r\n\tSerial.println(v, DEC);\r\n\tSerial.print(\" - a: \");\r\n\tSerial.println(a, DEC);\r\n}\r\n\r\nvoid _move3() {\r\n\t// movements[0].prepare(10000, MOV_ACCEL);\r\n\t// movements[0].setSteps(0, 1000);\r\n\t\r\n\tuint16_t nb_ticks = 13000; // nb_tick must be at least 2 times bigger than nb_steps\r\n\t\r\n\tmovements[0].movements[0].set(nb_ticks, 6400, MOV_ACCEL);\r\n\tmovements[1].movements[0].set(nb_ticks, 6400, MOV_DECCEL);\r\n\r\n\t//Movement * mov = &(movements[0].movements[0]);\r\n\tMovementsSync * sync_mov = &(movements[0]);\r\n\t\r\n\tuint16_t i = 0;\r\n\tuint16_t nb_steps_done = 0;\r\n\t//ESP.wdtDisable();\r\n\tuint32_t t1 = micros();\r\n\t// while(!(mov->complete())) {\r\n\t\t// i++;\r\n\t\t// if(mov->tick()) {\r\n\t\t\t// step();\r\n\t\t\t// nb_steps_done++;\r\n\t\t// }\r\n\t\t\r\n\t\t// delayMicroseconds(50);\r\n\t\t//yield();\r\n\t// }\r\n\tuint8_t mask;\r\n\twhile(!(sync_mov->complete())) {\r\n\t\tmask = sync_mov->tick();\r\n\t\tif(mask) {\r\n\t\t\tnb_steps_done++;\r\n\t\t}\r\n\t}\r\n\t\r\n\tuint32_t t2 = micros();\r\n\t//ESP.wdtEnable(1);\r\n\t\r\n\tSerial.print(\"time: \");\r\n\tSerial.println(((float) (t2 - t1)) / ((float) nb_ticks), DEC);\r\n\tSerial.print(\" - nb_steps_done: \");\r\n\tSerial.println(nb_steps_done, DEC);\r\n\tSerial.print(\" - i: \");\r\n\tSerial.println(i, DEC);\r\n\tSerial.println();\r\n}\r\n\r\nvoid setup() {\r\n\tSerial.begin(115200);\r\n\tdelay(1000);\r\n\tpinMode(13, OUTPUT);\r\n\tSerial.println(\"\\nstart\");\r\n\t\r\n\t\r\n\t//speed_test();\r\n\t// _move2(10000, 1000, MOV_ACCEL);\r\n\t// _move2(10000, 1000, MOV_DECCEL);\r\n\t// _move2(10000, 1000, MOV_LINEAR);\r\n\t\r\n\t// _move(10000, 1000, MOV_ACCEL);\r\n\t// _move(10000, 1000, MOV_DECCEL);\r\n\t// _move(10000, 1000, MOV_LINEAR);\r\n\t//timer_test();\r\n\t\r\n\t//_move3();\r\n\t\r\n}\r\n\r\nvoid loop() {\r\n\tif(Serial.available()) {\r\n        Serial.read();\r\n\t\t_move3();\r\n    }\r\n}\r\n");